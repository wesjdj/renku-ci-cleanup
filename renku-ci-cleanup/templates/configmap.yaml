apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "renku-ci-cleanup.fullname" . }}-script
  labels:
    {{- include "renku-ci-cleanup.labels" . | nindent 4 }}
data:
  cleanup.sh: |
    #!/bin/bash
    set -e
    
    echo "Starting Renku CI deployment cleanup..."
    echo "Max age: {{ .Values.cleanup.maxAge }} hours"
    echo "Exemption label: {{ .Values.cleanup.exemptionLabel }}"
    {{- if .Values.cleanup.enforceNamePatterns }}
    echo "Name pattern enforcement: enabled"
    echo "Allowed patterns:"
    {{- range .Values.cleanup.namespacePatterns }}
    echo "  - {{ . }}"
    {{- end }}
    {{- else }}
    echo "Name pattern enforcement: disabled"
    {{- end }}
    
    {{- if .Values.cleanup.prCleanup.enabled }}
    echo "PR-based cleanup: enabled"
    echo "Repository mappings:"
    {{- range .Values.cleanup.prCleanup.repositories }}
    echo "  - {{ .namespacePattern }} -> {{ .repo }}"
    {{- end }}
    {{- else }}
    echo "PR-based cleanup: disabled"
    {{- end }}
    
    {{- if .Values.cleanup.dryRun }}
    echo "DRY RUN MODE: No actual deletions will be performed"
    {{- end }}
    
    # Function to calculate age in seconds
    calculate_age() {
        local timestamp="$1"
        local current_time=$(date +%s)
        
        # Kubernetes timestamps are in ISO 8601 format, need to handle them properly
        local creation_time
        if command -v gdate >/dev/null 2>&1; then
            # Use GNU date if available (Linux with coreutils)
            creation_time=$(gdate -d "$timestamp" +%s 2>/dev/null || echo "0")
        else
            # For Alpine Linux/BusyBox date, we need to parse the ISO 8601 format manually
            # Format: 2025-05-28T13:50:39Z
            local year month day hour minute second
            year=$(echo "$timestamp" | cut -d'-' -f1)
            month=$(echo "$timestamp" | cut -d'-' -f2)
            day=$(echo "$timestamp" | cut -d'T' -f1 | cut -d'-' -f3)
            hour=$(echo "$timestamp" | cut -d'T' -f2 | cut -d':' -f1)
            minute=$(echo "$timestamp" | cut -d':' -f2)
            second=$(echo "$timestamp" | cut -d':' -f3 | sed 's/Z$//')
            
            # Use BusyBox date with explicit format
            local formatted_timestamp="${year}-${month}-${day} ${hour}:${minute}:${second}"
            creation_time=$(date -d "$formatted_timestamp" +%s 2>/dev/null || echo "0")
        fi
        
        if [ "$creation_time" = "0" ]; then
            echo "0"
        else
            echo $((current_time - creation_time))
        fi
    }
    
    # Function to format age for display
    format_age() {
        local age_seconds="$1"
        local age_hours=$((age_seconds / 3600))
        local age_days=$((age_hours / 24))
        
        if [ $age_days -gt 0 ]; then
            echo "${age_days}d $((age_hours % 24))h"
        else
            echo "${age_hours}h"
        fi
    }
    
    # Function to format hours to days+hours for thresholds
    format_hours_threshold() {
        local hours="$1"
        local days=$((hours / 24))
        
        if [ $days -gt 0 ]; then
            echo "${days}d ($((hours % 24))h)"
        else
            echo "${hours}h"
        fi
    }
    
    # Function to check if namespace matches any allowed pattern
    matches_pattern() {
        local namespace="$1"
        {{- if .Values.cleanup.enforceNamePatterns }}
        {{- range .Values.cleanup.namespacePatterns }}
        if [[ "$namespace" =~ {{ . }} ]]; then
            return 0
        fi
        {{- end }}
        return 1
        {{- else }}
        # Pattern enforcement disabled, always return true
        return 0
        {{- end }}
    }
    
    {{- if .Values.cleanup.prCleanup.enabled }}
    # Function to check GitHub PR status
    check_pr_status() {
        local namespace="$1"
        local github_token="${GITHUB_TOKEN}"
        
        if [ -z "$github_token" ]; then
            echo "  → GitHub token not configured, skipping PR status check"
            return 1
        fi
        
        # Check each repository mapping
        {{- range .Values.cleanup.prCleanup.repositories }}
        if [[ "$namespace" =~ {{ .namespacePattern }} ]]; then
            local pr_number
            {{- if .suffixPattern }}
            pr_number=$(echo "$namespace" | sed -E 's/{{ .namespacePattern }}/\1/')
            {{- else }}
            pr_number="${BASH_REMATCH[1]}"
            {{- end }}
            
            if [ -z "$pr_number" ]; then
                echo "  → Could not extract PR number from namespace $namespace"
                return 1
            fi
            
            echo "  → Checking PR #$pr_number status in {{ .repo }}"
            
            # Query GitHub API for PR status
            local pr_response
            pr_response=$(curl -s -H "Authorization: token $github_token" \
                "https://api.github.com/repos/{{ .repo }}/pulls/$pr_number" 2>/dev/null)
            
            if [ $? -ne 0 ]; then
                echo "  → Failed to query GitHub API for PR #$pr_number"
                return 1
            fi
            
            # Check if PR exists and get its state
            local pr_state
            pr_state=$(echo "$pr_response" | grep -o '"state":[[:space:]]*"[^"]*"' | sed 's/"state":[[:space:]]*"\([^"]*\)"/\1/')
            
            if [ -z "$pr_state" ]; then
                echo "  → PR #$pr_number not found in {{ .repo }}"
                return 0  # PR doesn't exist, can clean up
            fi
            
            echo "  → PR #$pr_number state: $pr_state"
            
            # Check if PR is closed or merged
            if [ "$pr_state" = "closed" ]; then
                # For closed PRs, check if it was merged
                local merged
                merged=$(echo "$pr_response" | grep -o '"merged":[[:space:]]*[^,}]*' | sed 's/"merged":[[:space:]]*\([^,}]*\)/\1/')
                if [ "$merged" = "true" ]; then
                    echo "  → PR #$pr_number is merged, eligible for cleanup"
                else
                    echo "  → PR #$pr_number is closed but not merged, eligible for cleanup"
                fi
                return 0  # Can clean up
            elif [ "$pr_state" = "open" ]; then
                echo "  → PR #$pr_number is still open, skipping cleanup"
                return 1  # Cannot clean up
            else
                echo "  → PR #$pr_number has unknown state: $pr_state"
                return 1  # Unknown state, skip cleanup
            fi
        fi
        {{- end }}
        
        echo "  → Namespace $namespace does not match any PR cleanup patterns"
        return 1  # No matching pattern
    }
    {{- end }}
    
    # Get maximum age in seconds
    MAX_AGE_SECONDS=$(( {{ .Values.cleanup.maxAge }} * 3600 ))
    
    # Find and process all namespaces
    kubectl get namespaces \
      -o jsonpath='{range .items[*]}{.metadata.name}{"\t"}{.metadata.creationTimestamp}{"\t"}{.metadata.labels}{"\n"}{end}' | \
      while IFS=$'\t' read -r namespace timestamp labels; do
        if [ -z "$namespace" ] || [ -z "$timestamp" ]; then
          continue
        fi
        
        age_seconds=$(calculate_age "$timestamp")
        age_display=$(format_age "$age_seconds")
        
        echo "Checking namespace: $namespace (age: $age_display)"
        
        # Check if namespace is exempt from cleanup
        if [[ "$labels" == *"{{ .Values.cleanup.exemptionLabel | replace "=" "\\=" }}"* ]]; then
          echo "  → Namespace $namespace is exempt from cleanup (has exemption label), skipping"
          continue
        fi
        
        # Check if namespace matches allowed patterns
        if ! matches_pattern "$namespace"; then
          echo "  → Namespace $namespace does not match any allowed patterns, skipping"
          continue
        fi
        
        # For matching namespaces, show age comparison with culling threshold
        remaining_seconds=$((MAX_AGE_SECONDS - age_seconds))
        remaining_hours=$((remaining_seconds / 3600))
        threshold_display=$(format_hours_threshold {{ .Values.cleanup.maxAge }})
        if [ "$remaining_seconds" -gt 0 ]; then
          echo "  → Namespace $namespace has ${remaining_hours}h remaining before cleanup (${age_display} < ${threshold_display} threshold)"
        else
          overdue_hours=$((-remaining_hours))
          echo "  → Namespace $namespace is ${overdue_hours}h overdue for cleanup (${age_display} > ${threshold_display} threshold)"
        fi
        
        # Check cleanup conditions
        should_cleanup=false
        cleanup_reason=""
        
        # Check age-based cleanup
        if [ "$age_seconds" -gt "$MAX_AGE_SECONDS" ]; then
          should_cleanup=true
          cleanup_reason="age-based (${age_display} > ${threshold_display})"
        fi
        
        {{- if .Values.cleanup.prCleanup.enabled }}
        # Check PR-based cleanup
        if check_pr_status "$namespace"; then
          should_cleanup=true
          if [ -n "$cleanup_reason" ]; then
            cleanup_reason="$cleanup_reason and PR-based"
          else
            cleanup_reason="PR-based (closed/merged PR)"
          fi
        fi
        {{- end }}
        
        if [ "$should_cleanup" = "true" ]; then
          echo "  → Namespace $namespace eligible for cleanup: $cleanup_reason"
          
          {{- if .Values.cleanup.dryRun }}
          echo "  → DRY RUN: Would clean up namespace $namespace ($cleanup_reason)"
          {{- else }}
          # Use rdu cleanup command with force flag to avoid interactive prompts
          if command -v rdu >/dev/null 2>&1; then
            echo "  → Using rdu cleanupdeployment for namespace $namespace"
            rdu cleanupdeployment --namespace "$namespace" --delete-namespace --force || {
              echo "  → Warning: rdu cleanup failed for $namespace, attempting manual cleanup"
              kubectl delete namespace "$namespace" --timeout=300s || echo "  → Failed to delete namespace $namespace"
            }
          else
            echo "  → rdu not available, performing manual cleanup"
            kubectl delete namespace "$namespace" --timeout=300s || echo "  → Failed to delete namespace $namespace"
          fi
          echo "  → Cleanup completed for namespace: $namespace"
          {{- end }}
        fi
      done
    
    echo "Renku CI deployment cleanup completed"